//// Std / FS
#include <iostream>
#include <filesystem>
#include <string>
#include <cstdlib>
#include <chrono>

// PCL
#include <pcl/common/transforms.h>
#include <pcl/registration/icp.h>
#include <pcl/point_types.h>

// Project headers
#include "MacTimer.hpp"
#include "MacConfig.hpp"
#include "MacData.hpp"
#include "MacGraph.hpp"
#include "MacSharp.hpp"
#include "MacRtHypothesis.hpp"
#include "MacUtils.hpp"
#include "MacMonitor.hpp"
#include "MacEvaluator.hpp"

// ----------------------------------------
// Registration pipeline
// ----------------------------------------

/**
 * @brief The main function for the registration pipeline.
 * This function executes the registration process: loads data, constructs graph, computes graph weights, finds maximal cliques,
 * generates RT hypotheses, and performs ICP refinement if enabled.
 * It also manages evaluation and logging.
 * @param macConfig Configuration object containing the settings for the registration process.
 * @param macData Data object containing the point clouds and correspondences.
 * @param macResult Result object where registration outputs will be stored.
 * @param monitor MacMonitor instance for tracking the time and memory usage during the process.
 * @return True if the registration is successful, false otherwise.
 */
bool registration(const MacConfig &macConfig, MacData &macData, MacResult &macResult,
                  MacMonitor& monitor) {
    Timer timer;
    timer.clearHistory();  // Clear any previous timing data

    // Reset macResult to ensure we start fresh
    macResult.reset();

    // Stage profiler tracks the hierarchical stages and logs their performance
    StageProfiler profiler(monitor); // new profiler for hierarchical rows

    // -------- load data --------
    {
        // Mark the beginning of the "loadData" stage
        auto l1 = profiler.enter("loadData");
        LOG_INFO("================ Loading data... ================");
        Timer t; t.startTiming("load data");  // Start timing for data loading

        // Load the data from disk using macData's loadData function
        if (!macData.loadData(macConfig)) {
            LOG_ERROR("Failed to load all essential data. Exiting registration.");
            t.endTiming();  // End timing if loadData fails
            profiler.recordHere(t.getLastElapsedTime());  // Record the time taken
            return false;  // Exit if loading data fails
        }
        t.endTiming();  // End timing once the data is successfully loaded
        profiler.recordHere(t.getTotalElapsedTime());  // Record the total time taken for the "loadData" stage
    }

    // U3M multipliers -> absolute thresholds (no-op for non-U3M)
    // Set mesh resolution for U3M dataset (if applicable)
    const_cast<MacConfig&>(macConfig).setRuntimeMeshResolutionForCurrentDataset(macData.cloudResolution);

    // -------- construct graph --------
    LOG_INFO("================ Constructing graph... ================");
    timer.startTiming("construct graph");
    MacGraph macGraph(macData, macConfig);  // Create graph object
    macGraph.build();  // Build the graph
    timer.endTiming();  // End timing for graph construction
    monitor.recordStage("constructGraph", timer);  // Record the stage time for graph construction

    // -------- compute graph weights --------
    LOG_INFO("================ Compute graph weights... ================");
    timer.startTiming("compute graph weights");
    macGraph.computeGraphDegree();  // Compute degree of vertices
    macGraph.calculateTriangularWeights();  // Calculate triangular weights for the graph
    // macGraph.calculateGraphThreshold(); // optional threshold calculation (commented out)
    timer.endTiming();  // End timing for graph weight computation
    monitor.recordStage("computeGraphWeights", timer);  // Record the stage time for computing graph weights

    // Store the ground truth inlier count from macData
    macResult.gtInlierNum = macData.gtInlierCount;

    // Evaluation-only: Ground truth inlier ratio
    {
        const float gtInlierRatio = (macData.totalCorresNum > 0)
                                    ? static_cast<float>(macData.gtInlierCount) / static_cast<float>(macData.totalCorresNum)
                                    : 0.0f;
        std::cout << "Ground truth inliers: " << macData.gtInlierCount
                  << "\t total num: "      << macData.totalCorresNum << std::endl;
        std::cout << "Ground truth inlier ratio: " << gtInlierRatio * 100.0f << "%" << std::endl;
    }

    // -------- cliques --------
    LOG_INFO("================ Finding maximal cliques... ================");
    timer.startTiming("find maximal cliques");
    macGraph.findMaximalCliques();  // Find the maximal cliques in the graph
    timer.endTiming();  // End timing for maximal clique search
    monitor.recordStage("findMaximalCliques", timer);  // Record the stage time for finding cliques

    // If no cliques are found, return an error
    if (macData.totalCliqueNum == 0) {
        LOG_ERROR("No cliques found in the graph.");
        return false;
    }

    // -------- hypotheses --------
    LOG_INFO("================ Generate RT hypotheses... ================");
    timer.startTiming("generate RT hypotheses");
    MacRtHypothesis macRtHypothesis(macData, macConfig, macGraph, macResult);  // Create hypothesis generator
    macRtHypothesis.processGraphResultAndFindBest(macGraph);  // Process the graph result and find the best RT hypothesis
    timer.endTiming();  // End timing for RT hypothesis generation
    monitor.recordStage("generateRtHypotheses", timer);  // Record the stage time for generating RT hypotheses

    // Retrieve the best transform from the hypothesis generator
    Eigen::Matrix4f finalTransform = macRtHypothesis.getBestTransform();

    // -------- optional ICP refine --------
    if (macConfig.flagUseIcp) {
        LOG_INFO("================ ICP refinement (optional)... ================");
        pcl::IterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> icp;
        icp.setInputSource(macData.cloudSrc);  // Set the source point cloud for ICP
        icp.setInputTarget(macData.cloudTgt);  // Set the target point cloud for ICP
        icp.setMaximumIterations(50);  // Set maximum iterations for ICP
        icp.setMaxCorrespondenceDistance(macConfig.threshold > 0.0f ? macConfig.threshold : 0.5f);  // Max correspondence distance
        icp.setTransformationEpsilon(1e-8);  // Transformation epsilon for convergence
        icp.setEuclideanFitnessEpsilon(1e-6);  // Fitness epsilon for convergence

        pcl::PointCloud<pcl::PointXYZ> aligned;
        pcl::PointCloud<pcl::PointXYZ> srcInit = *macData.cloudSrc;
        pcl::transformPointCloud(srcInit, aligned, finalTransform);  // Apply the initial transform

        icp.setInputSource(aligned.makeShared());  // Set the transformed source point cloud
        pcl::PointCloud<pcl::PointXYZ> refined;
        icp.align(refined);  // Perform ICP alignment

        // If ICP converges, update the final transform
        if (icp.hasConverged()) {
            Eigen::Matrix4f icpDelta = icp.getFinalTransformation();
            finalTransform = icpDelta * finalTransform;
            LOG_INFO("ICP converged. Fitness score: " << icp.getFitnessScore());
        } else {
            LOG_WARNING("ICP did not converge. Keeping the pre-ICP best transform.");
        }
    }

    // -------- final evaluation --------
    const bool pass = MacEvaluator::validateFinalTransform(finalTransform, macData, macConfig, macResult);

    // Store the total elapsed time for this registration call
    macResult.timeEpoch = timer.getTotalElapsedTime();  // Get the total elapsed time for the registration process

    return pass;
}

// ----------------------------------------
// main()
// ----------------------------------------

/**
 * @brief The main entry point for the program.
 * This function handles command-line arguments, loads the configuration file,
 * initializes necessary directories, and then starts the registration process.
 * @param argc Argument count
 * @param argv Argument values
 * @return 0 if registration was successful, -1 if there was an error
 */
int main(const int argc, char **argv) {
    if (argc == 1) {
        LOG_ERROR("Not enough arguments provided.");
        LOG_INFO("Usage: " << argv[0] << " <config_file>");
        return -1;
    }
    if (argc > 2) {
        LOG_WARNING("Too many arguments provided. Ignoring the rest.");
    }

    // Whole-session timer (informative)
    Timer timerAll;
    timerAll.clearHistory();
    timerAll.startTiming("Whole session");

    // Load the configuration file
    MacConfig macConfig;
    macConfig.load(argv[1]);
    LOG_INFO("MAC configuration loaded from: " << argv[1]);

    // Early validate (fail fast)
    if (!macConfig.validate()) {
        LOG_ERROR("Configuration is invalid. Please check required paths and datasetToRun.");
        return -1;
    }

    // Ensure output directory
    if (std::error_code ec; std::filesystem::exists(macConfig.outputPath, ec)) {
        LOG_WARNING("Output directory already exists: " << macConfig.outputPath
                    << ". Existing files may be overwritten."
                    << RESET << std::endl << "Press Enter to continue, or Ctrl+C to exit.");
        std::cin.get();
    } else {
        if (!std::filesystem::create_directory(macConfig.outputPath)) {
            LOG_ERROR("Error creating output directory: " << macConfig.outputPath);
            return -1;
        }
        LOG_INFO("Output directory created: " << macConfig.outputPath);
    }

    // Initialize run monitor (file logger + CSV timings)
    MacMonitor monitor;
    monitor.setProgramStart(std::chrono::high_resolution_clock::now());
    monitor.init(macConfig); // respects noLogFile

    // Set the number of threads for the program
    settingThreads(macConfig.desiredThreads);

    // Run the registration process
    MacData macData;
    MacResult macResult;
    const bool ok = registration(macConfig, macData, macResult, monitor);

    // End the whole session timer and record it in the log
    timerAll.endTiming();
    monitor.recordWholeSession(timerAll);

    // Output the result of the registration process
    if (ok) {
        std::cout << GREEN << "Registration successful" << RESET << std::endl;
    } else {
        std::cout << YELLOW << "Registration failed" << RESET << std::endl;
    }

    // Clean up and shutdown the monitor
    monitor.shutdown();
    return ok ? 0 : -1;
}
