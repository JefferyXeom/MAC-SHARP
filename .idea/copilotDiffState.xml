<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/include/RegistrationData.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/RegistrationData.hpp" />
              <option name="originalContent" value="//&#10;// Created by Jeffery_Xeom on 2025/8/24.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;pcl/point_cloud.h&gt;&#10;#include &quot;configLoader.hpp&quot; // 为了 MacConfig&#10;#include &quot;CommonTypes.hpp&quot;  // 新增：提供 PointCloudPtr、CorresStruct、日志宏、Eigen 等常用公共类型&#10;&#10;class RegistrationData {&#10;    // --- 私有辅助方法 (静态) ---&#10;    // 将它们设为静态(static)是因为它们不依赖于某个特定的RegistrationData实例的状态，&#10;    // 它们更像是独立的工具函数，只是逻辑上属于这个类。&#10;&#10;    /**&#10;     * @brief 为对应关系查找在关键点云中的索引&#10;     */&#10;    static void findIndexForCorrespondences(PointCloudPtr&amp; cloudSrcKpts, PointCloudPtr&amp; cloudTgtKpts,&#10;                                              std::vector&lt;CorresStruct&gt;&amp; corres);&#10;&#10;    /**&#10;     * @brief 计算点云的分辨率&#10;     */&#10;    static float meshResolutionCalculation(const PointCloudPtr&amp; pointcloud);&#10;&#10;    /**&#10;     * @brief 模板化的点云加载函数 (原loadPointCloud)&#10;     */&#10;    template&lt;typename PointT&gt;&#10;    static bool loadPointCloud(const std::string &amp;filePath, pcl::PointCloud&lt;PointT&gt; &amp;cloud);&#10;&#10;public:&#10;    // Input Data&#10;    PointCloudPtr cloudSrc;&#10;    PointCloudPtr cloudTgt;&#10;    PointCloudPtr cloudSrcKpts;&#10;    PointCloudPtr cloudTgtKpts;&#10;    std::vector&lt;CorresStruct&gt; corres;&#10;&#10;    // Ground Truth (for evaluation)&#10;    Eigen::Matrix4f gtTransform;&#10;    std::vector&lt;int&gt; gtInlierLabels;&#10;&#10;    // Calculated Properties&#10;    float cloudResolution;&#10;    int gtInlierCount;&#10;    int totalCorresNum; // No longer a global variable&#10;&#10;    // --- 公有成员方法 ---&#10;    /**&#10;     * @brief 构造函数：初始化所有智能指针&#10;     */&#10;    RegistrationData();&#10;&#10;    /**&#10;     * @brief 从配置文件加载所有相关数据&#10;     * @param config 配置对象&#10;     * @return 如果加载成功返回 true，否则返回 false&#10;     */&#10;    bool loadData(const MacConfig &amp;config);&#10;&#10;};&#10;" />
              <option name="updatedContent" value="//&#10;// Created by Jeffery_Xeom on 2025/8/24.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;pcl/point_cloud.h&gt;&#10;#include &quot;configLoader.hpp&quot; // 为了 MacConfig&#10;#include &quot;CommonTypes.hpp&quot;  // 新增：提供 PointCloudPtr、CorresStruct、日志宏、Eigen 等常用公共类型&#10;&#10;class RegistrationData {&#10;    // --- 私有辅助方法 (静态) ---&#10;    // 将它们设为静态(static)是因为它们不依赖于某个特定的RegistrationData实例的状态，&#10;    // 它们更像是独立的工具函数，只是逻辑上属于这个类。&#10;&#10;    /**&#10;     * @brief 为对应关系查找在关键点云中的索引&#10;     */&#10;    static void findIndexForCorrespondences(PointCloudPtr&amp; cloudSrcKpts, PointCloudPtr&amp; cloudTgtKpts,&#10;                                              std::vector&lt;CorresStruct&gt;&amp; corres);&#10;&#10;    /**&#10;     * @brief 计算点云的分辨率&#10;     */&#10;    static float meshResolutionCalculation(const PointCloudPtr&amp; pointcloud);&#10;&#10;    /**&#10;     * @brief 模板化的点云加载函数 (原loadPointCloud)&#10;     */&#10;    template&lt;typename PointT&gt;&#10;    static bool loadPointCloud(const std::string &amp;filePath, pcl::PointCloud&lt;PointT&gt; &amp;cloud);&#10;&#10;public:&#10;    // Input Data&#10;    PointCloudPtr cloudSrc;&#10;    PointCloudPtr cloudTgt;&#10;    PointCloudPtr cloudSrcKpts;&#10;    PointCloudPtr cloudTgtKpts;&#10;    std::vector&lt;CorresStruct&gt; corres;&#10;&#10;    // Ground Truth (for evaluation)&#10;    Eigen::Matrix4f gtTransform;&#10;    std::vector&lt;int&gt; gtInlierLabels;&#10;&#10;    // Calculated Properties&#10;    float cloudResolution;&#10;    int gtInlierCount;&#10;    int totalCorresNum; // No longer a global variable&#10;&#10;    // --- 公有成员方法 ---&#10;    /**&#10;     * @brief 构造函数：初始化所有智能指针&#10;     */&#10;    RegistrationData();&#10;&#10;    /**&#10;     * @brief 从配置文件加载所有相关数据&#10;     * @param config 配置对象&#10;     * @return 如果加载成功返回 true，否则返回 false&#10;     */&#10;    bool loadData(const MacConfig &amp;config);&#10;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/RegistrationData.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/RegistrationData.cpp" />
              <option name="originalContent" value="//&#10;// Created by Jeffery_Xeom on 2025/8/24.&#10;//&#10;&#10;#include &lt;fstream&gt;&#10;#include &lt;sstream&gt;    // 新增：TXT 加载需要解析每行&#10;#include &lt;algorithm&gt;  // 新增：扩展名小写转换需要&#10;#include &lt;cmath&gt;      // 新增：sqrt 计算&#10;#include &lt;pcl/io/pcd_io.h&gt;&#10;#include &lt;pcl/io/ply_io.h&gt;&#10;#include &lt;pcl/kdtree/kdtree_flann.h&gt;&#10;&#10;#include &quot;CommonTypes.hpp&quot;&#10;#include &quot;MacTimer.hpp&quot;&#10;#include &quot;RegistrationData.hpp&quot;&#10;&#10;&#10;/**&#10; * @brief 从不同格式的文件中加载点云（类静态方法）&#10; *  - 支持 .pcd/.ply/.bin/.txt&#10; *  - .bin 按 KITTI 风格读取每点4个float(x,y,z,intensity)，默认忽略强度&#10; *  - .txt 默认按行 &quot;x y z [其他]&quot;，忽略多余列和空/注释行&#10; * @tparam PointT 点的类型 (例如, pcl::PointXYZ, pcl::PointXYZI)&#10; * @param filePath 点云文件的路径&#10; * @param cloud 用于存储加载后点云的 PCL 点云对象&#10; * @return true 如果加载成功&#10; * @return false 如果加载失败&#10; */&#10;template&lt;typename PointT&gt;&#10;bool RegistrationData::loadPointCloud(const std::string &amp;filePath, pcl::PointCloud&lt;PointT&gt; &amp;cloud) {&#10;    // 1. 获取文件扩展名并转为小写&#10;    std::string extension;&#10;    size_t dot_pos = filePath.find_last_of('.');&#10;    if (dot_pos == std::string::npos) {&#10;        LOG_ERROR(&quot;Error: No file extension found in &quot; &lt;&lt; filePath);&#10;        return false;&#10;    }&#10;    extension = filePath.substr(dot_pos);&#10;    std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);&#10;&#10;    // 2. 根据扩展名选择加载方法&#10;    if (extension == &quot;.pcd&quot;) {&#10;        if (pcl::io::loadPCDFile&lt;PointT&gt;(filePath, cloud) == -1) {&#10;            LOG_ERROR(&quot;Can not open PCD file: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;    } else if (extension == &quot;.ply&quot;) {&#10;        if (pcl::io::loadPLYFile&lt;PointT&gt;(filePath, cloud) == -1) {&#10;            LOG_ERROR(&quot;Can not open PLY file: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;    } else if (extension == &quot;.bin&quot;) {&#10;        // 假设是 KITTI 数据集格式: float x, y, z, intensity&#10;        std::ifstream in(filePath, std::ios::binary);&#10;        if (!in.is_open()) {&#10;            LOG_ERROR(&quot;Can not open BIN file: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;        cloud.clear();&#10;        while (true) {&#10;            PointT point;&#10;            float x, y, z, intensity_val;&#10;            // 连续读取 4 个 float；若任一读取失败，跳出循环&#10;            if (!in.read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(float))) break;&#10;            if (!in.read(reinterpret_cast&lt;char *&gt;(&amp;y), sizeof(float))) break;&#10;            if (!in.read(reinterpret_cast&lt;char *&gt;(&amp;z), sizeof(float))) break;&#10;            if (!in.read(reinterpret_cast&lt;char *&gt;(&amp;intensity_val), sizeof(float))) break;&#10;&#10;            // 赋值几何坐标；强度字段可按需要写入（此处默认忽略）&#10;            point.x = x; point.y = y; point.z = z;&#10;            // 如果点类型是 PointXYZI，可取消下面的注释写入强度&#10;            // if constexpr (std::is_same_v&lt;PointT, pcl::PointXYZI&gt;) {&#10;            //     point.intensity = intensity_val;&#10;            // }&#10;            cloud.push_back(point);&#10;        }&#10;        if (!in.eof()) {&#10;            // 若非正常 EOF 结束，说明文件可能损坏&#10;            LOG_ERROR(&quot;The BIN file format is incorrect or corrupted: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;    } else if (extension == &quot;.txt&quot;) {&#10;        // 假设是 TXT 格式: 每行 x y z ...&#10;        std::ifstream in(filePath);&#10;        if (!in.is_open()) {&#10;            LOG_ERROR(&quot;Can not open TXT file: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;        cloud.clear();&#10;        std::string line;&#10;        while (std::getline(in, line)) {&#10;            // 跳过空行与注释行&#10;            if (line.empty() || line[0] == '#') continue;&#10;&#10;            std::stringstream ss(line);&#10;            PointT point;&#10;            // 至少需要读取 x, y, z&#10;            if (!(ss &gt;&gt; point.x &gt;&gt; point.y &gt;&gt; point.z)) {&#10;                continue; // 跳过格式错误的行&#10;            }&#10;            // 可在此继续读取更多字段，例如 rgb, intensity 等&#10;            cloud.push_back(point);&#10;        }&#10;    } else {&#10;        LOG_ERROR(&quot;Unsupported file format '&quot; &lt;&lt; extension &lt;&lt; &quot;' for file: &quot; &lt;&lt; filePath);&#10;        return false;&#10;    }&#10;&#10;    // 3. 确保点云有效&#10;    if (cloud.empty()) {&#10;        LOG_ERROR(&quot;Empty cloud input: &quot; &lt;&lt; filePath);&#10;        return false;&#10;    }&#10;&#10;    // 4. 统一设置点云元数据：非组织点云，稠密&#10;    cloud.width = cloud.size();   // 设置为点的总数&#10;    cloud.height = 1;             // 设置为1，表示无组织点云&#10;    cloud.is_dense = true;        // 假设所有点都有效&#10;&#10;    return true;&#10;}&#10;&#10;// The correspondences file contains the xyz coordinates of the source and target keypoints. But the order is the same&#10;//  with the original keypoints clouds. To associate it with kpts, we need to find the index of each correspondence in the original kpts clouds.&#10;// NOTE: the keypoints are not in the original point cloud, therefore nearest search is required.&#10;// Find the nearest point in the source and target key point clouds for each correspondence, and assign the indices to the correspondences.&#10;void RegistrationData::findIndexForCorrespondences(PointCloudPtr &amp;cloudSrcKpts, PointCloudPtr &amp;cloudTgtKpts,&#10;                                                   std::vector&lt;CorresStruct&gt; &amp;corres) {&#10;    // 使用 KD-Tree 在关键点云中查找每个对应关系的最近索引&#10;    pcl::KdTreeFLANN&lt;pcl::PointXYZ&gt; kdtreeSrcKpts, kdtreeTgtKpts;&#10;    kdtreeSrcKpts.setInputCloud(cloudSrcKpts);&#10;    kdtreeTgtKpts.setInputCloud(cloudTgtKpts);&#10;    std::vector&lt;int&gt; kdtreeSrcIndex(1), kdtreeTgtIndex(1);&#10;    std::vector&lt;float&gt; kdtreeSrcDistance(1), kdtreeTgtDistance(1);&#10;    for (auto &amp;corr: corres) {&#10;        pcl::PointXYZ srcPoint, tgtPoint;&#10;        srcPoint = corr.src;&#10;        tgtPoint = corr.tgt;&#10;        kdtreeSrcKpts.nearestKSearch(srcPoint, 1, kdtreeSrcIndex, kdtreeSrcDistance);&#10;        kdtreeTgtKpts.nearestKSearch(tgtPoint, 1, kdtreeTgtIndex, kdtreeTgtDistance);&#10;        corr.srcIndex = kdtreeSrcIndex[0];&#10;        corr.tgtIndex = kdtreeTgtIndex[0];&#10;    }&#10;}&#10;&#10;float RegistrationData::meshResolutionCalculation(const PointCloudPtr &amp;pointcloud) {&#10;    // 使用均值最近邻距离来近似点云分辨率（mean root）&#10;    float mr = 0.0f; // mean root&#10;    pcl::KdTreeFLANN&lt;pcl::PointXYZ&gt; kdtree;&#10;    std::vector&lt;int&gt; point_idx;    // 最近邻索引&#10;    std::vector&lt;float&gt; point_dis;  // 最近邻距离平方&#10;    kdtree.setInputCloud(pointcloud);&#10;&#10;    // 遍历每个点，查找最近邻（k=2，第一个是自身，第二个是最近邻）&#10;    for (auto query_point : pointcloud-&gt;points) {&#10;        kdtree.nearestKSearch(query_point, 2, point_idx, point_dis);&#10;        mr += std::sqrt(point_dis[1]); // 距离从平方还原&#10;    }&#10;    mr /= static_cast&lt;float&gt;(pointcloud-&gt;points.size());&#10;    return mr; // 近似分辨率&#10;}&#10;&#10;/**&#10; * @brief 构造函数：初始化所有点云指针与评估相关成员&#10; *  - 指针指向新的空点云，避免 nullptr&#10; *  - gtTransform 置为单位阵&#10; *  - 计数与统计清零&#10; */&#10;RegistrationData::RegistrationData()&#10;    : cloudSrc(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()),&#10;      cloudTgt(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()),&#10;      cloudSrcKpts(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()),&#10;      cloudTgtKpts(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()),&#10;      cloudResolution(0.0f),&#10;      gtInlierCount(0),&#10;      totalCorresNum(0) {&#10;    gtTransform = Eigen::Matrix4f::Identity();&#10;}&#10;&#10;/**&#10; * @brief 从配置中加载所有数据到 RegistrationData 的成员&#10; *  - 点云与关键点：支持 pcd/ply/bin/txt&#10; *  - 对应关系：必需，有则读取；索引文件可选，缺失时自动基于关键点查找最近邻索引&#10; *  - GT 变换/标签：可选，无则以无评估模式继续&#10; *  - 自动计算点云分辨率&#10; */&#10;bool RegistrationData::loadData(const MacConfig &amp;macConfig) {&#10;    // 清理旧数据，确保幂等&#10;    corres.clear();&#10;    gtInlierLabels.clear();&#10;    gtInlierCount = 0;&#10;    totalCorresNum = 0;&#10;    cloudResolution = 0.0f;&#10;    cloudSrc-&gt;clear();&#10;    cloudTgt-&gt;clear();&#10;    cloudSrcKpts-&gt;clear();&#10;    cloudTgtKpts-&gt;clear();&#10;    gtTransform.setIdentity();&#10;&#10;    Timer timerLoadData;&#10;    LOG_INFO(&quot;Output path: &quot; &lt;&lt; macConfig.outputPath);&#10;&#10;    // --------------------- 读取点云与关键点 ---------------------&#10;    timerLoadData.startTiming(&quot;load data: load cloud points&quot;);&#10;&#10;    // 定义一个辅助加载函数，用于检查、加载并打印错误信息&#10;    auto load_and_check = [&amp;](const std::string &amp;path, auto &amp;cloud_ptr, const std::string &amp;description) -&gt; bool {&#10;        // 使用类静态方法，根据扩展名自动选择加载器&#10;        if (!RegistrationData::loadPointCloud(path, *cloud_ptr)) {&#10;            LOG_ERROR(&quot;Unable to load &quot; &lt;&lt; description &lt;&lt; &quot; from: &quot; &lt;&lt; path);&#10;            return false;&#10;        }&#10;        if (cloud_ptr-&gt;empty()) {&#10;            LOG_ERROR(description &lt;&lt; &quot; is empty after loading from: &quot; &lt;&lt; path);&#10;            return false;&#10;        }&#10;        LOG_INFO(&quot;Successfully loaded &quot; &lt;&lt; description &lt;&lt; &quot; with &quot; &lt;&lt; cloud_ptr-&gt;size()&#10;                 &lt;&lt; &quot; points from: &quot; &lt;&lt; path);&#10;        return true;&#10;    };&#10;&#10;    // 依次加载所有点云和关键点&#10;    if (!load_and_check(macConfig.cloudSrcPath,  cloudSrc,     &quot;source point cloud&quot;)) return false;&#10;    if (!load_and_check(macConfig.cloudTgtPath,  cloudTgt,     &quot;target point cloud&quot;)) return false;&#10;    if (!load_and_check(macConfig.cloudSrcKptPath, cloudSrcKpts, &quot;source keypoints&quot;))   return false;&#10;    if (!load_and_check(macConfig.cloudTgtKptPath, cloudTgtKpts, &quot;target keypoints&quot;))   return false;&#10;&#10;    timerLoadData.endTiming();&#10;&#10;    // --------------------- 读取对应关系与索引 ---------------------&#10;    timerLoadData.startTiming(&quot;load data: load and process correspondences&quot;);&#10;&#10;    std::ifstream corresFile(macConfig.corresPath);&#10;    std::ifstream corresIndexFile(macConfig.corresIndexPath);&#10;&#10;    // Note that in our version of test data, the source and target matched kpts clouds are already corresponded.&#10;    // But for the original MAC paper, the source and target matched kpts clouds are not corresponded.&#10;    // Load correspondences, xyz&#10;    if (!corresFile.is_open()) {&#10;        LOG_ERROR(&quot;Unable to open correspondence file: &quot; &lt;&lt; macConfig.corresPath);&#10;        return false;&#10;    }&#10;    CorresStruct match;&#10;    pcl::PointXYZ srcPoint, tgtPoint; // source point and target point in each match&#10;    while (corresFile &gt;&gt; srcPoint.x &gt;&gt; srcPoint.y &gt;&gt; srcPoint.z &gt;&gt;&#10;           tgtPoint.x &gt;&gt; tgtPoint.y &gt;&gt; tgtPoint.z) {&#10;        match.src = srcPoint;&#10;        match.tgt = tgtPoint;&#10;        match.inlierWeight = 0; // 初始化内点权重&#10;        corres.push_back(match);&#10;    }&#10;    totalCorresNum = static_cast&lt;int&gt;(corres.size());&#10;    LOG_INFO(&quot;Successfully loaded &quot; &lt;&lt; totalCorresNum &lt;&lt; &quot; correspondences from: &quot; &lt;&lt; macConfig.corresPath);&#10;&#10;    // 对应关系索引（可选）：缺失则基于关键点查找最近邻索引&#10;    if (!corresIndexFile.is_open()) {&#10;        LOG_INFO(&quot;No correspondence index file provided: &quot; &lt;&lt; macConfig.corresIndexPath&#10;                 &lt;&lt; &quot;. Finding indices for correspondences.&quot;);&#10;        RegistrationData::findIndexForCorrespondences(cloudSrcKpts, cloudTgtKpts, corres);&#10;    } else {&#10;        int i = 0;&#10;        while (i != static_cast&lt;int&gt;(corres.size()) &amp;&amp; (corresIndexFile &gt;&gt; corres[i].srcIndex &gt;&gt; corres[i].tgtIndex)) {&#10;            i++;&#10;        }&#10;        if (i &gt; totalCorresNum) {&#10;            LOG_WARNING(&quot;Too many correspondences in the index file: &quot; &lt;&lt; macConfig.corresPath&#10;                        &lt;&lt; &quot;. This is probably a wrong index file. Ignoring the rest.&quot;);&#10;        } else if (i &lt; totalCorresNum) {&#10;            LOG_WARNING(&quot;Not enough correspondences in the index file: &quot; &lt;&lt; macConfig.corresPath&#10;                        &lt;&lt; &quot;. This is probably a wrong index file. Some correspondences will be missing indices.&quot;);&#10;        }&#10;    }&#10;&#10;    timerLoadData.endTiming();&#10;&#10;    // --------------------- 计算点云分辨率 ---------------------&#10;    timerLoadData.startTiming(&quot;load data: calculate mesh resolution&quot;);&#10;    cloudResolution = (RegistrationData::meshResolutionCalculation(cloudSrc)&#10;                      +RegistrationData::meshResolutionCalculation(cloudTgt)) / 2.0f;&#10;    LOG_INFO(&quot;Cloud resolution: &quot; &lt;&lt; cloudResolution);&#10;    timerLoadData.endTiming();&#10;&#10;    // --------------------- 评估部分（可选） ---------------------&#10;    timerLoadData.startTiming(&quot;load data: load and process ground truth data&quot;);&#10;    LOG_DEBUG(&quot;----------------Evaluation part----------------&quot;);&#10;&#10;    // Ground Truth 变换矩阵（可选）&#10;    if (std::ifstream gtTfFile(macConfig.gtTfPath); !gtTfFile.is_open()) {&#10;            LOG_DEBUG(&quot;No ground truth transformation data: &quot; &lt;&lt; macConfig.gtTfPath&#10;                &lt;&lt; &quot;. System working without evaluation.&quot;);&#10;            // SETTING the no evaluation flag. It is still not implemented.&#10;    } else {&#10;        // 读取 4x4 变换矩阵&#10;        gtTfFile &gt;&gt; gtTransform(0, 0) &gt;&gt; gtTransform(0, 1) &gt;&gt; gtTransform(0, 2) &gt;&gt; gtTransform(0, 3);&#10;        gtTfFile &gt;&gt; gtTransform(1, 0) &gt;&gt; gtTransform(1, 1) &gt;&gt; gtTransform(1, 2) &gt;&gt; gtTransform(1, 3);&#10;        gtTfFile &gt;&gt; gtTransform(2, 0) &gt;&gt; gtTransform(2, 1) &gt;&gt; gtTransform(2, 2) &gt;&gt; gtTransform(2, 3);&#10;        gtTfFile &gt;&gt; gtTransform(3, 0) &gt;&gt; gtTransform(3, 1) &gt;&gt; gtTransform(3, 2) &gt;&gt; gtTransform(3, 3);&#10;        LOG_DEBUG(&quot;Ground truth transformation matrix: \n&quot; &lt;&lt; gtTransform);&#10;    }&#10;&#10;    // Ground Truth 内点标签（可选）&#10;    if (std::ifstream gtLabelFile(macConfig.gtLabelPath); !gtLabelFile.is_open()) {&#10;        if (macConfig.flagVerbose) {&#10;            LOG_DEBUG(&quot;No Ground truth correspondence data: &quot; &lt;&lt; macConfig.gtLabelPath&#10;                      &lt;&lt; &quot;. System working without evaluation.&quot;);&#10;        }&#10;    } else {&#10;        // 原 MAC++ 版本：逐值读取内/外点标记（1 表示内点）&#10;        int value = 0;&#10;        while (gtLabelFile &gt;&gt; value) {&#10;            gtInlierLabels.push_back(value);&#10;            if (value == 1) {&#10;                gtInlierCount++;&#10;            }&#10;        }&#10;&#10;        if (gtInlierCount == 0) {&#10;            LOG_DEBUG(&quot;No inliers found in the ground truth correspondences.&quot;);&#10;        }&#10;        const float inlier_ratio = (totalCorresNum &gt; 0)&#10;                                   ? static_cast&lt;float&gt;(gtInlierCount) / static_cast&lt;float&gt;(totalCorresNum)&#10;                                   : 0.0f;&#10;        LOG_DEBUG(&quot;Inlier ratio: &quot; &lt;&lt; inlier_ratio * 100 &lt;&lt; &quot;%, GT inliers: &quot; &lt;&lt; gtInlierCount&#10;                  &lt;&lt; &quot;, total correspondences: &quot; &lt;&lt; totalCorresNum);&#10;    }&#10;    LOG_DEBUG(&quot;-----------------------------------------------&quot;);&#10;    timerLoadData.endTiming();&#10;&#10;    return true;&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Created by Jeffery_Xeom on 2025/8/24.&#10;//&#10;&#10;#include &lt;fstream&gt;&#10;#include &lt;sstream&gt;    // 新增：TXT 加载需要解析每行&#10;#include &lt;algorithm&gt;  // 新增：扩展名小写转换需要&#10;#include &lt;cmath&gt;      // 新增：sqrt 计算&#10;#include &lt;pcl/io/pcd_io.h&gt;&#10;#include &lt;pcl/io/ply_io.h&gt;&#10;#include &lt;pcl/kdtree/kdtree_flann.h&gt;&#10;&#10;#include &quot;CommonTypes.hpp&quot;&#10;#include &quot;MacTimer.hpp&quot;&#10;#include &quot;RegistrationData.hpp&quot;&#10;&#10;&#10;/**&#10; * @brief 从不同格式的文件中加载点云（类静态方法）&#10; *  - 支持 .pcd/.ply/.bin/.txt&#10; *  - .bin 按 KITTI 风格读取每点4个float(x,y,z,intensity)，默认忽略强度&#10; *  - .txt 默认按行 &quot;x y z [其他]&quot;，忽略多余列和空/注释行&#10; * @tparam PointT 点的类型 (例如, pcl::PointXYZ, pcl::PointXYZI)&#10; * @param filePath 点云文件的路径&#10; * @param cloud 用于存储加载后点云的 PCL 点云对象&#10; * @return true 如果加载成功&#10; * @return false 如果加载失败&#10; */&#10;template&lt;typename PointT&gt;&#10;bool RegistrationData::loadPointCloud(const std::string &amp;filePath, pcl::PointCloud&lt;PointT&gt; &amp;cloud) {&#10;    // 1. 获取文件扩展名并转为小写&#10;    std::string extension;&#10;    size_t dot_pos = filePath.find_last_of('.');&#10;    if (dot_pos == std::string::npos) {&#10;        LOG_ERROR(&quot;Error: No file extension found in &quot; &lt;&lt; filePath);&#10;        return false;&#10;    }&#10;    extension = filePath.substr(dot_pos);&#10;    std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);&#10;&#10;    // 2. 根据扩展名选择加载方法&#10;    if (extension == &quot;.pcd&quot;) {&#10;        if (pcl::io::loadPCDFile&lt;PointT&gt;(filePath, cloud) == -1) {&#10;            LOG_ERROR(&quot;Can not open PCD file: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;    } else if (extension == &quot;.ply&quot;) {&#10;        if (pcl::io::loadPLYFile&lt;PointT&gt;(filePath, cloud) == -1) {&#10;            LOG_ERROR(&quot;Can not open PLY file: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;    } else if (extension == &quot;.bin&quot;) {&#10;        // 假设是 KITTI 数据集格式: float x, y, z, intensity&#10;        std::ifstream in(filePath, std::ios::binary);&#10;        if (!in.is_open()) {&#10;            LOG_ERROR(&quot;Can not open BIN file: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;        cloud.clear();&#10;        while (true) {&#10;            PointT point;&#10;            float x, y, z, intensity_val;&#10;            // 连续读取 4 个 float；若任一读取失败，跳出循环&#10;            if (!in.read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(float))) break;&#10;            if (!in.read(reinterpret_cast&lt;char *&gt;(&amp;y), sizeof(float))) break;&#10;            if (!in.read(reinterpret_cast&lt;char *&gt;(&amp;z), sizeof(float))) break;&#10;            if (!in.read(reinterpret_cast&lt;char *&gt;(&amp;intensity_val), sizeof(float))) break;&#10;&#10;            // 赋值几何坐标；强度字段可按需要写入（此处默认忽略）&#10;            point.x = x; point.y = y; point.z = z;&#10;            // 如果点类型是 PointXYZI，可取消下面的注释写入强度&#10;            // if constexpr (std::is_same_v&lt;PointT, pcl::PointXYZI&gt;) {&#10;            //     point.intensity = intensity_val;&#10;            // }&#10;            cloud.push_back(point);&#10;        }&#10;        if (!in.eof()) {&#10;            // 若非正常 EOF 结束，说明文件可能损坏&#10;            LOG_ERROR(&quot;The BIN file format is incorrect or corrupted: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;    } else if (extension == &quot;.txt&quot;) {&#10;        // 假设是 TXT 格式: 每行 x y z ...&#10;        std::ifstream in(filePath);&#10;        if (!in.is_open()) {&#10;            LOG_ERROR(&quot;Can not open TXT file: &quot; &lt;&lt; filePath);&#10;            return false;&#10;        }&#10;        cloud.clear();&#10;        std::string line;&#10;        while (std::getline(in, line)) {&#10;            // 跳过空行与注释行&#10;            if (line.empty() || line[0] == '#') continue;&#10;&#10;            std::stringstream ss(line);&#10;            PointT point;&#10;            // 至少需要读取 x, y, z&#10;            if (!(ss &gt;&gt; point.x &gt;&gt; point.y &gt;&gt; point.z)) {&#10;                continue; // 跳过格式错误的行&#10;            }&#10;            // 可在此继续读取更多字段，例如 rgb, intensity 等&#10;            cloud.push_back(point);&#10;        }&#10;    } else {&#10;        LOG_ERROR(&quot;Unsupported file format '&quot; &lt;&lt; extension &lt;&lt; &quot;' for file: &quot; &lt;&lt; filePath);&#10;        return false;&#10;    }&#10;&#10;    // 3. 确保点云有效&#10;    if (cloud.empty()) {&#10;        LOG_ERROR(&quot;Empty cloud input: &quot; &lt;&lt; filePath);&#10;        return false;&#10;    }&#10;&#10;    // 4. 统一设置点云元数据：非组织点云，稠密&#10;    cloud.width = cloud.size();   // 设置为点的总数&#10;    cloud.height = 1;             // 设置为1，表示无组织点云&#10;    cloud.is_dense = true;        // 假设所有点都有效&#10;&#10;    return true;&#10;}&#10;&#10;// The correspondences file contains the xyz coordinates of the source and target keypoints. But the order is the same&#10;//  with the original keypoints clouds. To associate it with kpts, we need to find the index of each correspondence in the original kpts clouds.&#10;// NOTE: the keypoints are not in the original point cloud, therefore nearest search is required.&#10;// Find the nearest point in the source and target key point clouds for each correspondence, and assign the indices to the correspondences.&#10;void RegistrationData::findIndexForCorrespondences(PointCloudPtr &amp;cloudSrcKpts, PointCloudPtr &amp;cloudTgtKpts,&#10;                                                   std::vector&lt;CorresStruct&gt; &amp;corres) {&#10;    // 使用 KD-Tree 在关键点云中查找每个对应关系的最近索引&#10;    pcl::KdTreeFLANN&lt;pcl::PointXYZ&gt; kdtreeSrcKpts, kdtreeTgtKpts;&#10;    kdtreeSrcKpts.setInputCloud(cloudSrcKpts);&#10;    kdtreeTgtKpts.setInputCloud(cloudTgtKpts);&#10;    std::vector&lt;int&gt; kdtreeSrcIndex(1), kdtreeTgtIndex(1);&#10;    std::vector&lt;float&gt; kdtreeSrcDistance(1), kdtreeTgtDistance(1);&#10;    for (auto &amp;corr: corres) {&#10;        pcl::PointXYZ srcPoint, tgtPoint;&#10;        srcPoint = corr.src;&#10;        tgtPoint = corr.tgt;&#10;        kdtreeSrcKpts.nearestKSearch(srcPoint, 1, kdtreeSrcIndex, kdtreeSrcDistance);&#10;        kdtreeTgtKpts.nearestKSearch(tgtPoint, 1, kdtreeTgtIndex, kdtreeTgtDistance);&#10;        corr.srcIndex = kdtreeSrcIndex[0];&#10;        corr.tgtIndex = kdtreeTgtIndex[0];&#10;    }&#10;}&#10;&#10;float RegistrationData::meshResolutionCalculation(const PointCloudPtr &amp;pointcloud) {&#10;    // 使用均值最近邻距离来近似点云分辨率（mean root）&#10;    float mr = 0.0f; // mean root&#10;    pcl::KdTreeFLANN&lt;pcl::PointXYZ&gt; kdtree;&#10;    std::vector&lt;int&gt; point_idx;    // 最近邻索引&#10;    std::vector&lt;float&gt; point_dis;  // 最近邻距离平方&#10;    kdtree.setInputCloud(pointcloud);&#10;&#10;    // 遍历每个点，查找最近邻（k=2，第一个是自身，第二个是最近邻）&#10;    for (auto query_point : pointcloud-&gt;points) {&#10;        kdtree.nearestKSearch(query_point, 2, point_idx, point_dis);&#10;        mr += std::sqrt(point_dis[1]); // 距离从平方还原&#10;    }&#10;    mr /= static_cast&lt;float&gt;(pointcloud-&gt;points.size());&#10;    return mr; // 近似分辨率&#10;}&#10;&#10;/**&#10; * @brief 构造函数：初始化所有点云指针与评估相关成员&#10; *  - 指针指向新的空点云，避免 nullptr&#10; *  - gtTransform 置为单位阵&#10; *  - 计数与统计清零&#10; */&#10;RegistrationData::RegistrationData()&#10;    : cloudSrc(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()),&#10;      cloudTgt(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()),&#10;      cloudSrcKpts(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()),&#10;      cloudTgtKpts(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()),&#10;      cloudResolution(0.0f),&#10;      gtInlierCount(0),&#10;      totalCorresNum(0) {&#10;    gtTransform = Eigen::Matrix4f::Identity();&#10;}&#10;&#10;/**&#10; * @brief 从配置中加载所有数据到 RegistrationData 的成员&#10; *  - 点云与关键点：支持 pcd/ply/bin/txt&#10; *  - 对应关系：必需，有则读取；索引文件可选，缺失时自动基于关键点查找最近邻索引&#10; *  - GT 变换/标签：可选，无则以无评估模式继续&#10; *  - 自动计算点云分辨率&#10; */&#10;bool RegistrationData::loadData(const MacConfig &amp;macConfig) {&#10;    // 清理旧数据，确保幂等&#10;    corres.clear();&#10;    gtInlierLabels.clear();&#10;    gtInlierCount = 0;&#10;    totalCorresNum = 0;&#10;    cloudResolution = 0.0f;&#10;    cloudSrc-&gt;clear();&#10;    cloudTgt-&gt;clear();&#10;    cloudSrcKpts-&gt;clear();&#10;    cloudTgtKpts-&gt;clear();&#10;    gtTransform.setIdentity();&#10;&#10;    Timer timerLoadData;&#10;    LOG_INFO(&quot;Output path: &quot; &lt;&lt; macConfig.outputPath);&#10;&#10;    // --------------------- 读取点云与关键点 ---------------------&#10;    timerLoadData.startTiming(&quot;load data: load cloud points&quot;);&#10;&#10;    // 定义一个辅助加载函数，用于检查、加载并打印错误信息&#10;    auto load_and_check = [&amp;](const std::string &amp;path, auto &amp;cloud_ptr, const std::string &amp;description) -&gt; bool {&#10;        // 使用类静态方法，根据扩展名自动选择加载器&#10;        if (!RegistrationData::loadPointCloud(path, *cloud_ptr)) {&#10;            LOG_ERROR(&quot;Unable to load &quot; &lt;&lt; description &lt;&lt; &quot; from: &quot; &lt;&lt; path);&#10;            return false;&#10;        }&#10;        if (cloud_ptr-&gt;empty()) {&#10;            LOG_ERROR(description &lt;&lt; &quot; is empty after loading from: &quot; &lt;&lt; path);&#10;            return false;&#10;        }&#10;        LOG_INFO(&quot;Successfully loaded &quot; &lt;&lt; description &lt;&lt; &quot; with &quot; &lt;&lt; cloud_ptr-&gt;size()&#10;                 &lt;&lt; &quot; points from: &quot; &lt;&lt; path);&#10;        return true;&#10;    };&#10;&#10;    // 依次加载所有点云和关键点&#10;    if (!load_and_check(macConfig.cloudSrcPath,  cloudSrc,     &quot;source point cloud&quot;)) return false;&#10;    if (!load_and_check(macConfig.cloudTgtPath,  cloudTgt,     &quot;target point cloud&quot;)) return false;&#10;    if (!load_and_check(macConfig.cloudSrcKptPath, cloudSrcKpts, &quot;source keypoints&quot;))   return false;&#10;    if (!load_and_check(macConfig.cloudTgtKptPath, cloudTgtKpts, &quot;target keypoints&quot;))   return false;&#10;&#10;    timerLoadData.endTiming();&#10;&#10;    // --------------------- 读取对应关系与索引 ---------------------&#10;    timerLoadData.startTiming(&quot;load data: load and process correspondences&quot;);&#10;&#10;    std::ifstream corresFile(macConfig.corresPath);&#10;    std::ifstream corresIndexFile(macConfig.corresIndexPath);&#10;&#10;    // Note that in our version of test data, the source and target matched kpts clouds are already corresponded.&#10;    // But for the original MAC paper, the source and target matched kpts clouds are not corresponded.&#10;    // Load correspondences, xyz&#10;    if (!corresFile.is_open()) {&#10;        LOG_ERROR(&quot;Unable to open correspondence file: &quot; &lt;&lt; macConfig.corresPath);&#10;        return false;&#10;    }&#10;    CorresStruct match;&#10;    pcl::PointXYZ srcPoint, tgtPoint; // source point and target point in each match&#10;    while (corresFile &gt;&gt; srcPoint.x &gt;&gt; srcPoint.y &gt;&gt; srcPoint.z &gt;&gt;&#10;           tgtPoint.x &gt;&gt; tgtPoint.y &gt;&gt; tgtPoint.z) {&#10;        match.src = srcPoint;&#10;        match.tgt = tgtPoint;&#10;        match.inlierWeight = 0; // 初始化内点权重&#10;        corres.push_back(match);&#10;    }&#10;    totalCorresNum = static_cast&lt;int&gt;(corres.size());&#10;    LOG_INFO(&quot;Successfully loaded &quot; &lt;&lt; totalCorresNum &lt;&lt; &quot; correspondences from: &quot; &lt;&lt; macConfig.corresPath);&#10;&#10;    // 对应关系索引（可选）：缺失则基于关键点查找最近邻索引&#10;    if (!corresIndexFile.is_open()) {&#10;        LOG_INFO(&quot;No correspondence index file provided: &quot; &lt;&lt; macConfig.corresIndexPath&#10;                 &lt;&lt; &quot;. Finding indices for correspondences.&quot;);&#10;        RegistrationData::findIndexForCorrespondences(cloudSrcKpts, cloudTgtKpts, corres);&#10;    } else {&#10;        int i = 0;&#10;        while (i != static_cast&lt;int&gt;(corres.size()) &amp;&amp; (corresIndexFile &gt;&gt; corres[i].srcIndex &gt;&gt; corres[i].tgtIndex)) {&#10;            i++;&#10;        }&#10;        if (i &gt; totalCorresNum) {&#10;            LOG_WARNING(&quot;Too many correspondences in the index file: &quot; &lt;&lt; macConfig.corresPath&#10;                        &lt;&lt; &quot;. This is probably a wrong index file. Ignoring the rest.&quot;);&#10;        } else if (i &lt; totalCorresNum) {&#10;            LOG_WARNING(&quot;Not enough correspondences in the index file: &quot; &lt;&lt; macConfig.corresPath&#10;                        &lt;&lt; &quot;. This is probably a wrong index file. Some correspondences will be missing indices.&quot;);&#10;        }&#10;    }&#10;&#10;    timerLoadData.endTiming();&#10;&#10;    // --------------------- 计算点云分辨率 ---------------------&#10;    timerLoadData.startTiming(&quot;load data: calculate mesh resolution&quot;);&#10;    cloudResolution = (RegistrationData::meshResolutionCalculation(cloudSrc)&#10;                      +RegistrationData::meshResolutionCalculation(cloudTgt)) / 2.0f;&#10;    LOG_INFO(&quot;Cloud resolution: &quot; &lt;&lt; cloudResolution);&#10;    timerLoadData.endTiming();&#10;&#10;    // --------------------- 评估部分（可选） ---------------------&#10;    timerLoadData.startTiming(&quot;load data: load and process ground truth data&quot;);&#10;    LOG_DEBUG(&quot;----------------Evaluation part----------------&quot;);&#10;&#10;    // Ground Truth 变换矩阵（可选）&#10;    if (std::ifstream gtTfFile(macConfig.gtTfPath); !gtTfFile.is_open()) {&#10;            LOG_DEBUG(&quot;No ground truth transformation data: &quot; &lt;&lt; macConfig.gtTfPath&#10;                &lt;&lt; &quot;. System working without evaluation.&quot;);&#10;            // SETTING the no evaluation flag. It is still not implemented.&#10;    } else {&#10;        // 读取 4x4 变换矩阵&#10;        gtTfFile &gt;&gt; gtTransform(0, 0) &gt;&gt; gtTransform(0, 1) &gt;&gt; gtTransform(0, 2) &gt;&gt; gtTransform(0, 3);&#10;        gtTfFile &gt;&gt; gtTransform(1, 0) &gt;&gt; gtTransform(1, 1) &gt;&gt; gtTransform(1, 2) &gt;&gt; gtTransform(1, 3);&#10;        gtTfFile &gt;&gt; gtTransform(2, 0) &gt;&gt; gtTransform(2, 1) &gt;&gt; gtTransform(2, 2) &gt;&gt; gtTransform(2, 3);&#10;        gtTfFile &gt;&gt; gtTransform(3, 0) &gt;&gt; gtTransform(3, 1) &gt;&gt; gtTransform(3, 2) &gt;&gt; gtTransform(3, 3);&#10;        LOG_DEBUG(&quot;Ground truth transformation matrix: \n&quot; &lt;&lt; gtTransform);&#10;    }&#10;&#10;    // Ground Truth 内点标签（可选）&#10;    if (std::ifstream gtLabelFile(macConfig.gtLabelPath); !gtLabelFile.is_open()) {&#10;        if (macConfig.flagVerbose) {&#10;            LOG_DEBUG(&quot;No Ground truth correspondence data: &quot; &lt;&lt; macConfig.gtLabelPath&#10;                      &lt;&lt; &quot;. System working without evaluation.&quot;);&#10;        }&#10;    } else {&#10;        // 原 MAC++ 版本：逐值读取内/外点标记（1 表示内点）&#10;        int value = 0;&#10;        while (gtLabelFile &gt;&gt; value) {&#10;            gtInlierLabels.push_back(value);&#10;            if (value == 1) {&#10;                gtInlierCount++;&#10;            }&#10;        }&#10;&#10;        if (gtInlierCount == 0) {&#10;            LOG_DEBUG(&quot;No inliers found in the ground truth correspondences.&quot;);&#10;        }&#10;        const float inlier_ratio = (totalCorresNum &gt; 0)&#10;                                   ? static_cast&lt;float&gt;(gtInlierCount) / static_cast&lt;float&gt;(totalCorresNum)&#10;                                   : 0.0f;&#10;        LOG_DEBUG(&quot;Inlier ratio: &quot; &lt;&lt; inlier_ratio * 100 &lt;&lt; &quot;%, GT inliers: &quot; &lt;&lt; gtInlierCount&#10;                  &lt;&lt; &quot;, total correspondences: &quot; &lt;&lt; totalCorresNum);&#10;    }&#10;    LOG_DEBUG(&quot;-----------------------------------------------&quot;);&#10;    timerLoadData.endTiming();&#10;&#10;    return true;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>